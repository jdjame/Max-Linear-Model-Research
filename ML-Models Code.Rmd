---
title: "Max-Linear Models"
author: "Jean-Yves Djamen"
date: 'Fall 2019'
output: pdf_document
---
\def\d{\mathcal{D}}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
suppressWarnings(suppressMessages(library(network)))
suppressWarnings(suppressMessages(library(sna)))
suppressWarnings(suppressMessages(library(ggplot2)))
suppressWarnings(suppressMessages(library(GGally)))
suppressWarnings(suppressMessages(library(igraph)))
suppressWarnings(suppressMessages(library(DescTools)))
suppressWarnings(suppressMessages(library(VGAM)))
```


\tableofcontents{}
\pagebreak

\section{Given a graph, Generate ML Coefficient Matrix}
```{r echo=FALSE}
ml_gen<- function(n, mat_vector){
  #'We will assume that the function takes in as input n, and an nxn matrix detailing the values of each edge It will retrun the ML coef matrix
  
  #create adjacency matrix from input. I understand it as the transpose of what r interprets
  edge_adjacency<- t(matrix(mat_vector, nrow=n, ncol=n))
  #creates directed network graph from matrix with weights as input
  network_graph<-graph_from_adjacency_matrix(edge_adjacency, mode="directed", weighted=TRUE)
  
  #Finds all simple paths from a starting node
  paths<-list()
  for(e in 1:n)
    paths<-c(paths,(all_simple_paths(graph=network_graph,from=e, mode="out")))
  #initialize path value list
  path_vals<-list()
  #for every path, compose coeficients
  for(p in paths){
    starting_node=p[0,1]
    first_coef=edge_adjacency[starting_node,starting_node]
    inner_prod=1
    #path coefficients (after initial one )
    for(i in 2:length(p)){
      current_coef<-edge_adjacency[p[i-1],p[i]]
      inner_prod=current_coef*inner_prod
    }
    #make list of path products
    path_vals<-c(path_vals,first_coef*inner_prod)
  }
  #matrix to be returned 
  ml.coef.mat<-matrix(0,n,n)
  #fill in the diagonal entries
  for(i in 1:n){
    ml.coef.mat[i,i]=edge_adjacency[i,i]
  }
  #fill out the values at each cell
  for(e in 1:length(path_vals)){
    current.path=paths[e]
    source=current.path[[1]][1]
    destination=current.path[[1]][length(current.path[[1]])]
    #the value only gets filled out if current value is less than the desired one
    if(ml.coef.mat[source,destination]<path_vals[e]){
      ml.coef.mat[source,destination]<-path_vals[e][[1]]
    }
  }
  return(ml.coef.mat)
}
graph_gen<-function(n,mat_vector){
  mat<- matrix(mat_vector, nrow=n, ncol=n)
  colnames(mat)=rownames(mat)=1:n
  network=graph_from_adjacency_matrix(t(mat))
  plot(network)
}
```
We will assume that the input is a graph $\d= (V,E)$ with $n$ vertices.  Our function `ml_gen` will  output the ML coefficient matrix $B$ as shown bellow.
```{r}
m<- 4
m_mat<-c(2,3,4,1,
         0,2,0,4,
         0,0,3,5,
         0,0,0,2)
coef.mat<-ml_gen(m,m_mat)
```

\section{Generating some data}
To generate the data, we need to use the coefficient matrix $B$. From the analysis of this matrix, we can see that any comlumn $j$ denotes the maximum path between anode $j$ and each of its ancestors (denoted $An(j)$). In each column, a zero in the $i^{th}$ element means that there is no path between $i$ and $j$. So, to build the function that will generate data from the coefficient matrix, we compute the element wise product of our random vector $Z$ and each column $B_i$. Then, the maximum element in each of these will give us the value for our recursive structural model. In the following function this step is repeated several times to produce several sample points. 
```{r}
#given a max linear matrix and an optional input, generate some data
data_gen<-function(ml.mat, dist="exponential",lambda=1, s=1, alpha=1, m=0, samples=100){
  #lambda,s ,alpha, m are all parameters for the distribution
  #sampels denotes how many samples we woiuld like to generate
  #This is the number of nodes in our graph
  n<-nrow(ml.mat)
  
  if(dist=="frechet"){
    #s is scale, alpha is shape and m is location
    z<-rfrechet(n*samples, loc=m, scale=s, shape=alpha)
  }
  
  else{
    z<-rexp(n*samples, rate=1)
  }
  
  #turning Z into a matrix of (n x samples) size where n is the number of nodes in graph and samples is the number of samples we want to generate
  z=matrix(z, nrow=n, ncol=samples)
  
  #now we use our max prod function to calculate the max prod for each of our functions
  return(t(apply(z, 2, function(x) max_times_prd(x, ml.mat))))
}

max_times_prd<-function(mat1,mat2){
  #This function takes in two matrixes and does the max times algebta
  #here mat 1 is the Z column and mat2 is the coefficient matrix
  return(apply(mat2, 2, function(x) max(mat1*x)))
}
```

\subsection{Exponential Data}
With the exponential data we observe the following:

\subsubsection{100 Samples}
```{r}
exponential.1<-data_gen(coef.mat,dist="exponential",samples=100)
pobs <- apply(exponential.1,2,rank)/(101)
pairs(pobs)
```
From this, we can see something. I fear I am not trained enough to fully understand this though

\subsubsection{1000 Samples}
```{r}
exponential.2<-data_gen(coef.mat,dist="exponential",samples=1000)
pobs <- apply(exponential.2,2,rank)/(1001)
pairs(pobs)
```

\subsubsection{10000 Samples}
```{r}
exponential.3<-data_gen(coef.mat,dist="exponential",samples=10000)
pobs <- apply(exponential.3,2,rank)/(10001)
pairs(pobs)
```


\subsubsection{100000 Samples}
```{r}
exponential.4<-data_gen(coef.mat,dist="exponential",samples=100000)
pobs <- apply(exponential.4,2,rank)/(100001)
pairs(pobs)
```



\subsection{Frechet Distribution}
\subsubsection{100 Samples}
```{r}
frechet.1<-data_gen(coef.mat,dist="frechet",samples=100)
pobs <- apply(frechet.1,2,rank)/(101)
pairs(pobs)
```

\subsubsection{1000 Samples}
```{r}
frechet.2<-data_gen(coef.mat,dist="frechet",samples=1000)
pobs <- apply(frechet.2,2,rank)/(1001)
pairs(pobs)
```

\subsubsection{10000 Samples}
```{r}
frechet.3<-data_gen(coef.mat,dist="frechet",samples=10000)
pobs <- apply(frechet.3,2,rank)/(10001)
pairs(pobs)
```

\subsubsection{100000 Samples}
```{r}
frechet.4<-data_gen(coef.mat,dist="frechet",samples=100000)
pobs <- apply(frechet.4,2,rank)/(100001)
pairs(pobs)
```

